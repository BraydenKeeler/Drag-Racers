<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Drag Racers - Visual Car Select</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            background-color: #222;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            cursor: default; 
        }
        
        #gameContainer {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            border: 4px solid #444;
        }

        canvas {
            display: block;
            background-color: #87CEEB;
            image-rendering: pixelated;
        }
        
        /* Style for the hidden text input */
        #cheatInput {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            padding: 15px;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            color: black;
            background-color: white;
            border: 5px solid #FFD700;
            text-align: center;
            box-sizing: border-box;
            display: none; /* Initially hidden */
        }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas" width="960" height="540"></canvas>
    <input type="text" id="cheatInput" placeholder="Enter Code">
</div>

<script>
/**
 * DRAG RACERS - MULTI-SHAPE, MULTI-MODE (v26.0 - Visual Car Select)
 * Changes: 
 * 1. Implemented a visual, pixelated garage for STATE_CAR_SELECT.
 * 2. Added a function to draw the selected car's shape in the center of the garage.
 * 3. Added a lock icon and clear purchase message for unowned cars in Career mode.
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const cheatInput = document.getElementById('cheatInput');

// --- GAME STATES & CONSTANTS ---
const STATE_TITLE = 0;
const STATE_MODE_SELECT = 1;      
const STATE_CAR_SELECT = 2; // Dedicated Car Selection Screen
const STATE_DIFFICULTY = 3;
const STATE_TRACK_SELECT = 4; // Dedicated Track Selection Screen
const STATE_COUNTDOWN = 5;
const STATE_RACING = 6;
const STATE_GAMEOVER = 7;
const STATE_FALSE_START = 8;
const STATE_CHEAT_INPUT = 9; 

let gameState = STATE_TITLE;
let difficulty = 'EASY'; 
let selectedTrack = 'HALF_MILE'; 
const TRACK_OPTIONS = ['QUARTER_MILE', 'HALF_MILE', 'ONE_MILE'];

let frameCount = 0;
let isPvP = false; 
let selectedMode = 'CAREER'; // 'CAREER' or 'PVP'

// --- PLAYER PROGRESS DATA ---
let playerProgress = {
    coins: 1000, // Starting with some coins to make it easier to test
    purchasedCars: [0] 
};

// --- DIFFICULTY ORDER ---
const DIFFICULTY_OPTIONS = ['EASY', 'MEDIUM', 'HARD', 'EXPERT', 'LEGEND'];

// --- ECONOMY DEFINITIONS ---
const CHEAT_AMOUNT = 13000000;
const CAR_PRICES = [
    0, 75000, 95000, 115000, 130000, 
    200000, 300000, 600000, 1000000, 9999999      
];

const RACE_COSTS = {
    'EASY': 100, 'MEDIUM': 2000, 'HARD': 15000,
    'EXPERT': 50000, 'LEGEND': 150000
};

const RACE_PAYOUTS = {
    'EASY': 1000, 'MEDIUM': 6000, 'HARD': 30000,
    'EXPERT': 100000, 'LEGEND': 350000
};

// --- CAR DATA DEFINITIONS ---
const CAR_COLORS = [
    { name: 'Mustang', color: '#A00000', accent: '#FFFFFF', accelerationIndex: 9, shapeIndex: 0 }, 
    { name: 'Honda Civic', color: '#6688AA', accent: '#AAAAAA', accelerationIndex: 8, shapeIndex: 1 },
    { name: 'Supra', color: '#FF6600', accent: '#FFFFFF', accelerationIndex: 7, shapeIndex: 2 },
    { name: 'Corvette', color: '#550000', accent: '#FF6600', accelerationIndex: 6, shapeIndex: 3 },
    { name: 'Acura NSX', color: '#0066AA', accent: '#FFFFFF', accelerationIndex: 5, shapeIndex: 4 },
    { name: 'Nissan GTR', color: '#2B3D50', accent: '#AA0000', accelerationIndex: 4, shapeIndex: 5 },
    { name: 'Lamborghini', color: '#FFD700', accent: '#000000', accelerationIndex: 3, shapeIndex: 6 },
    { name: 'Pagani', color: '#660066', accent: '#CCCCCC', accelerationIndex: 2, shapeIndex: 7 },
    { name: 'Ferrari', color: '#CC0000', accent: '#FFD700', accelerationIndex: 1, shapeIndex: 8 },
    { name: 'Bugatti', color: '#0A1428', accent: '#D0D0D0', accelerationIndex: 0, shapeIndex: 9 } 
];

const PERFORMANCE_MULTIPLIERS = [1.20, 1.18, 1.16, 1.14, 1.12, 1.10, 1.08, 1.06, 1.04, 1.02];

// --- SHIFTING CONSTANTS ---
const MAX_RPM_DISPLAY = 9000;
const SHIFT_POINT_RPM = 7500; 
const OPTIMAL_SHIFT_START_RPM = 6500;
const LATE_SHIFT_RPM_THRESHOLD = SHIFT_POINT_RPM; 
const LATE_SHIFT_PENALTY_FACTOR = 0.5; 
const IDLE_RPM = 1000;

let selectedCarIndex = 0; 
let selectedCarIndex2 = 1; 
const TRACK_DEFINITIONS = {
    'QUARTER_MILE': 402.34, 'HALF_MILE': 804.67, 'ONE_MILE': 1609.34    
};
let TRACK_LENGTH = TRACK_DEFINITIONS['HALF_MILE']; 

const MPH_TO_MS = 0.44704; 
const MS_TO_MPH = 2.23694; 
const FPS = 60; 
const BASE_SPEED_MULTIPLIER = 1.5; 
const BASE_GEAR_CURVE = [
    { startMPH: 0, targetMPH: 0, timeSec: 0 }, 
    { startMPH: 0, targetMPH: 45, timeSec: 1.0 / BASE_SPEED_MULTIPLIER }, 
    { startMPH: 45, targetMPH: 70, timeSec: 2.5 / BASE_SPEED_MULTIPLIER }, 
    { startMPH: 70, targetMPH: 95, timeSec: 2.0 / BASE_SPEED_MULTIPLIER }, 
    { startMPH: 95, targetMPH: 120, timeSec: 2.5 / BASE_SPEED_MULTIPLIER }, 
    { startMPH: 120, targetMPH: 160, timeSec: 5.0 / BASE_SPEED_MULTIPLIER }, 
    { startMPH: 160, targetMPH: 200, timeSec: 8.0 / BASE_SPEED_MULTIPLIER }, 
    { startMPH: 200, targetMPH: 225, timeSec: 99.0 / BASE_SPEED_MULTIPLIER } 
];

// Keys - Player 1 (Arrows) and Player 2 (WASD)
const keys = {
    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, 
    Space: false, Enter: false, ArrowLeftSelect: false, ArrowRightSelect: false,
    KeyW: false, KeyS: false, KeyA: false, KeyD: false, KeyR: false
};

// --- AUDIO SETUP ---
let audioCtx;
let engineOscillator = null;
let gainNode = null;
let isEngineRunning = false;

function initAudio() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
}
function playSound(frequency, duration, type = 'sine', volume = 0.5) {
    if (!audioCtx) return;
    const oscillator = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    oscillator.type = type;
    oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
    gain.gain.setValueAtTime(volume, audioCtx.currentTime);

    oscillator.connect(gain);
    gain.connect(audioCtx.destination);
    
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + duration);
}
function startEngineSound() {
    if (!audioCtx || isEngineRunning) return;
    
    engineOscillator = audioCtx.createOscillator();
    gainNode = audioCtx.createGain();

    engineOscillator.type = 'square';
    engineOscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    
    gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
    
    engineOscillator.start();
    isEngineRunning = true;
}
function stopEngineSound() {
    if (engineOscillator) {
        gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.5);
        setTimeout(() => {
            if (engineOscillator) engineOscillator.stop();
            engineOscillator = null;
            isEngineRunning = false;
        }, 500);
    }
}
function updateEngineSound(rpm, state) {
    if (!engineOscillator || !audioCtx) return;

    if (state === STATE_COUNTDOWN && (keys.ArrowLeft && keys.ArrowRight || keys.KeyA && keys.KeyD)) {
        const targetFreq = 100 + (rpm / MAX_RPM_DISPLAY) * 300;
        engineOscillator.frequency.linearRampToValueAtTime(targetFreq, audioCtx.currentTime + 0.1);
        gainNode.gain.linearRampToValueAtTime(0.6, audioCtx.currentTime + 0.1);

    } else if (state === STATE_RACING || state === STATE_GAMEOVER) {
        const targetFreq = 50 + (rpm / MAX_RPM_DISPLAY) * 400; 
        const volume = 0.2 + (rpm / MAX_RPM_DISPLAY) * 0.5;
        engineOscillator.frequency.linearRampToValueAtTime(targetFreq, audioCtx.currentTime + 0.05);
        gainNode.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + 0.05);
    } else {
        gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
    }
}

// --- PLAYER PROGRESS & PERSISTENCE ---

function loadProgress() {
    try {
        const savedProgress = localStorage.getItem('dragRacersProgress');
        if (savedProgress) {
            const loadedData = JSON.parse(savedProgress);
            // Merge loaded data with defaults, ensuring arrays are correct type
            playerProgress.coins = loadedData.coins !== undefined ? loadedData.coins : 1000;
            playerProgress.purchasedCars = Array.isArray(loadedData.purchasedCars) ? loadedData.purchasedCars : [0];
            
            // Re-select car if the current index isn't owned or if it's out of bounds
            if (!playerProgress.purchasedCars.includes(selectedCarIndex)) {
                selectedCarIndex = playerProgress.purchasedCars[0] || 0;
            }
        }
    } catch (e) {
        console.error("Could not load progress from localStorage:", e);
        // Fallback to default progress defined at the top
    }
}

function saveProgress() {
    try {
        localStorage.setItem('dragRacersProgress', JSON.stringify(playerProgress));
    } catch (e) {
        console.error("Could not save progress to localStorage:", e);
    }
}

function resetProgress() {
    playerProgress = {
        coins: 1000,
        purchasedCars: [0]
    };
    selectedCarIndex = 0;
    saveProgress();
    gameMessage = "PROGRESS RESET TO DEFAULT!";
    playSound(1200, 0.5, 'sine', 1.0);
    setTimeout(() => { gameMessage = ""; }, 3000);
}

// --- CAR CLASS (Unchanged) ---
class Car {
    constructor(isPlayer, isPlayer2, carData) {
        this.isPlayer = isPlayer;
        this.isPlayer2 = isPlayer2;
        this.name = carData.name;
        this.color = carData.color; 
        this.accentColor = carData.accent;
        this.accelerationIndex = carData.accelerationIndex;
        this.performanceMultiplier = PERFORMANCE_MULTIPLIERS[carData.accelerationIndex];
        this.shapeIndex = carData.shapeIndex;

        this.x = 50;
        
        if (isPvP) {
             this.y = isPlayer ? 460 : 380;
        } else {
             this.y = isPlayer ? 380 : 300;
        }

        this.distance = 0;
        this.speed = 0; 
        this.rpm = IDLE_RPM;
        this.gear = 1;
        
        this.accelStartFrame = 0;
        this.accelTargetFrames = 0;
        this.startSpeedMS = 0;
        this.targetSpeedMS = 0;
        this.penaltyFactor = 1.0; 
        this.isReadyToLaunch = false;
        
        this.aiReactionTime = 0;
        this.aiShiftPoint = 0;
        this.aiSpeedMultiplier = 1.0; 
    }
    
    setCarData(carData) {
        this.name = carData.name;
        this.color = carData.color;
        this.accentColor = carData.accent;
        this.accelerationIndex = carData.accelerationIndex;
        this.performanceMultiplier = PERFORMANCE_MULTIPLIERS[carData.accelerationIndex];
        this.shapeIndex = carData.shapeIndex;
    }

    reset() {
        this.x = 50;
        this.distance = 0;
        this.speed = 0;
        this.rpm = IDLE_RPM;
        this.gear = 1;
        this.penaltyFactor = 1.0;
        this.isReadyToLaunch = false;
        
        if (isPvP) {
             this.y = this.isPlayer ? 460 : 380;
        } else {
             this.y = this.isPlayer ? 380 : 300;
        }
        
        if (this.isPlayer || this.isPlayer2) {
            this.accelStartFrame = 0;
            this.updatePlayerTargets();
        }
        
        if (!this.isPlayer && !this.isPlayer2) { 
            
            let baseSpeed = 0;
            let reactionFrames = 0;
            let shiftRPM = SHIFT_POINT_RPM;

            if (difficulty === 'EASY') {
                baseSpeed = 1.9; reactionFrames = 25; shiftRPM = OPTIMAL_SHIFT_START_RPM; 
            } else if (difficulty === 'MEDIUM') {
                baseSpeed = 2.2; reactionFrames = 8; shiftRPM = 7200;
            } else if (difficulty === 'HARD') {
                baseSpeed = 2.7; reactionFrames = 5; shiftRPM = SHIFT_POINT_RPM; 
            } else if (difficulty === 'EXPERT') {
                baseSpeed = 3.5; reactionFrames = 1; shiftRPM = SHIFT_POINT_RPM; 
            } else if (difficulty === 'LEGEND') {
                baseSpeed = 5.0; reactionFrames = 0; shiftRPM = SHIFT_POINT_RPM; 
            }

            this.aiShiftPoint = shiftRPM;
            this.aiReactionTime = reactionFrames;
            this.aiSpeedMultiplier = baseSpeed; 
            
            let carRankFactor = this.performanceMultiplier / 1.02; 
            this.aiSpeedMultiplier *= carRankFactor;
        }
    }
    
    updatePlayerTargets() {
        if ((!this.isPlayer && !this.isPlayer2) || this.gear < 1 || this.gear >= BASE_GEAR_CURVE.length) return;
        
        const baseCurve = BASE_GEAR_CURVE[this.gear];
        const currentMPH = this.speed * MS_TO_MPH;
        
        if (this.gear > 1 && currentMPH < BASE_GEAR_CURVE[this.gear - 1].targetMPH) {
            this.penaltyFactor = 0.5;
        } else {
            if (this.penaltyFactor === 1.0) { 
                 this.penaltyFactor = 1.0;
            }
        }
        
        this.accelStartFrame = frameCount;
        
        if (this.gear === 1 && !this.isReadyToLaunch) {
             this.startSpeedMS = 0;
        } else {
             this.startSpeedMS = this.speed;
        }
        
        this.targetSpeedMS = baseCurve.targetMPH * MPH_TO_MS * this.performanceMultiplier;
        this.accelTargetFrames = (baseCurve.timeSec * FPS) / this.penaltyFactor / this.performanceMultiplier;
    }

    updatePlayer(upKey, downKey, leftKey, rightKey) {
        if (this.gear === 0 || !this.isReadyToLaunch) {
            this.speed *= 0.98;
            if (leftKey) this.speed *= 0.95;
            if (this.speed < 0) this.speed = 0;
            this.rpm = IDLE_RPM;
            
            if (gameState === STATE_COUNTDOWN && leftKey && rightKey) {
                 this.rpm = 8000 + Math.sin(frameCount * 0.1) * 500;
            }
            return;
        }

        const framesPassed = frameCount - this.accelStartFrame;

        if (framesPassed <= this.accelTargetFrames) {
            const progress = framesPassed / this.accelTargetFrames;
            this.speed = this.startSpeedMS + (this.targetSpeedMS - this.startSpeedMS) * progress;
            
            let startRPM = IDLE_RPM;
            if (this.gear > 1) {
                 startRPM = Math.max(IDLE_RPM, SHIFT_POINT_RPM * 0.6); 
            }
            
            this.rpm = startRPM + progress * (MAX_RPM_DISPLAY - startRPM);
            
            if (this.rpm > 8500) this.rpm = 8500;

        } else {
            this.speed = this.targetSpeedMS;
            this.rpm = IDLE_RPM + 0.8 * (MAX_RPM_DISPLAY - IDLE_RPM);
        }

        if (this.rpm < IDLE_RPM) this.rpm = IDLE_RPM;
    }

    updateCPU() {
        let throttle = 0;
        
        if (gameState === STATE_RACING) {
            if (frameCount > startFrame + this.aiReactionTime) {
                throttle = 1;
                if (this.rpm > this.aiShiftPoint && this.gear < 7) {
                    this.shift(1);
                }
            }
        }

        const gearRatios = [0, 3.136, 2.101, 1.520, 1.177, 0.929, 0.775, 0.655];
        const finalDrive = 3.94;
        const wheelDiameterMeters = 0.68; 
        
        const currentRatio = gearRatios[this.gear] || 0.1;
        const driveRatio = currentRatio * finalDrive;
        const tireCircumference = Math.PI * wheelDiameterMeters;

        if (throttle > 0 && this.gear > 0) {
            let torque = 1.0;
            if (this.rpm < 3000) torque = 0.8; 
            if (this.rpm > SHIFT_POINT_RPM) torque = 0.5; 
            
            let gearMultiplier = currentRatio / 3.136; 
            let accelerationForce = 0.45 * torque * gearMultiplier;

            accelerationForce *= this.aiSpeedMultiplier; 

            this.speed += accelerationForce;
        }

        let airResistance = (this.speed * this.speed) * 0.00015; 
        this.speed -= airResistance;
        this.speed *= 0.998; 
        
        if (this.speed < 0) this.speed = 0;

        if (this.gear > 0) {
            let revsPerSec = this.speed / tireCircumference;
            let engineRevsPerSec = revsPerSec * driveRatio;
            this.rpm = engineRevsPerSec * 60;
        }
        if (this.rpm < IDLE_RPM) this.rpm = IDLE_RPM;
    }

    update() {
        if (this.isPlayer) {
            this.updatePlayer(keys.ArrowUp, keys.ArrowDown, keys.ArrowLeft, keys.ArrowRight);
        } else if (this.isPlayer2) {
            this.updatePlayer(keys.KeyW, keys.KeyS, keys.KeyA, keys.KeyD);
        } else {
            this.updateCPU();
        }
        
        if (this.speed > 0) {
            this.distance += (this.speed * 0.016);
        }
    }

    shift(dir) {
        if (dir === 1 && this.gear < 7) {
            
            if (this.rpm > LATE_SHIFT_RPM_THRESHOLD) {
                this.penaltyFactor = LATE_SHIFT_PENALTY_FACTOR; 
                if (this.isPlayer || this.isPlayer2) playSound(100, 0.1, 'sawtooth', 0.5); 
            } else {
                this.penaltyFactor = 1.0;
                if (this.isPlayer || this.isPlayer2) playSound(500, 0.1, 'sine', 0.5); 
            }

            this.gear++;
            this.updatePlayerTargets();
            
        } else if (dir === -1 && this.gear > 1) {
            this.gear--;
            this.penaltyFactor = 1.0;
            this.updatePlayerTargets();
        }
    }
    
    // Draw the car on the track (unmodified)
    draw(cameraX) {
        let screenX = this.x + (this.distance * 10) - cameraX;

        const w = 150;
        const h = 40;
        const drawY = this.y - h + 10;
        
        drawSelectedCarShape(screenX, drawY, w, h, this.color, this.accentColor, this.shapeIndex, false);
        
        ctx.fillStyle = '#444';
        ctx.fillRect(screenX + 40, drawY + 5, w - 80, h / 2);
        
        ctx.fillStyle = '#000';
        ctx.fillRect(screenX + 15, this.y - 10, 20, 10);
        ctx.fillRect(screenX + w - 35, this.y - 10, 20, 10);
        
        ctx.fillStyle = this.accentColor;
        ctx.font = "8px 'Press Start 2P'";
        ctx.textAlign = "center";
        let label = this.isPlayer ? "P1" : (this.isPlayer2 ? "P2" : "CPU");
        ctx.fillText(label, screenX + w / 2, drawY - 5);
    }
}

// --- GLOBAL VARIABLES & INPUT HANDLING ---
const player = new Car(true, false, CAR_COLORS[0]); 
const cpu = new Car(false, false, CAR_COLORS[1]);
const player2 = new Car(false, true, CAR_COLORS[1]); 

let cameraX = 0;
let lightsState = 0; 
let startFrame = 0;
let winnerText = "";
let showRestart = false;
let treeScrollPosition = 0; 
let gameMessage = "";
let finishedPlayers = []; 

let raceStartTime = 0;
let raceFinishTime = 0;
let liveRaceTime = 0;
let raceFinishTime2 = 0;

function formatCurrency(amount) {
    return "$" + amount.toLocaleString('en-US');
}

function startRaceSequence() {
    if (!isPvP) {
        const cost = RACE_COSTS[difficulty];
        
        if (playerProgress.coins < cost) {
            gameMessage = `NOT ENOUGH COINS! Requires ${formatCurrency(cost)}.`;
            gameState = STATE_TRACK_SELECT; 
            setTimeout(() => { gameMessage = ""; }, 3000);
            return; 
        }
        if (cost > 0) {
            playerProgress.coins -= cost;
            saveProgress();
        }
        
        player.isPlayer2 = false;
        player.setCarData(CAR_COLORS[selectedCarIndex]);
        player.reset();

        const availableCars = CAR_COLORS.filter((car, index) => index !== selectedCarIndex);
        const cpuCarData = availableCars[Math.floor(Math.random() * availableCars.length)];
        cpu.isPlayer2 = false;
        cpu.setCarData(cpuCarData); 
        cpu.reset(); 
        
    } else {
        player.isPlayer2 = false;
        player.setCarData(CAR_COLORS[selectedCarIndex]);
        player.reset();
        
        player2.isPlayer2 = true;
        player2.setCarData(CAR_COLORS[selectedCarIndex2]);
        player2.reset();
        
        cpu.distance = -9999;
        cpu.speed = 0;
    }
    
    TRACK_LENGTH = TRACK_DEFINITIONS[selectedTrack];
    gameState = STATE_COUNTDOWN;
    cameraX = 0;
    startEngineSound();
    raceStartTime = 0;
    raceFinishTime = 0;
    raceFinishTime2 = 0;
    liveRaceTime = 0;
    finishedPlayers = [];
}

function handleDifficultySelectKeys() {
    const currentIndex = DIFFICULTY_OPTIONS.indexOf(difficulty);
    let newIndex = currentIndex;
    const numOptions = DIFFICULTY_OPTIONS.length;

    if (keys.ArrowLeftSelect) {
        newIndex = (currentIndex - 1 + numOptions) % numOptions;
    }
    if (keys.ArrowRightSelect) {
        newIndex = (currentIndex + 1) % numOptions;
    }
    
    if (newIndex !== currentIndex) {
        difficulty = DIFFICULTY_OPTIONS[newIndex];
    }
}

function handleTrackSelectKeys() {
    const currentIndex = TRACK_OPTIONS.indexOf(selectedTrack);
    let newIndex = currentIndex;
    const numOptions = TRACK_OPTIONS.length;

    if (keys.ArrowLeftSelect) {
        newIndex = (currentIndex - 1 + numOptions) % numOptions;
        keys.ArrowLeftSelect = false; // Debounce
    }
    if (keys.ArrowRightSelect) {
        newIndex = (currentIndex + 1) % numOptions;
        keys.ArrowRightSelect = false; // Debounce
    }
    
    if (newIndex !== currentIndex) {
        selectedTrack = TRACK_OPTIONS[newIndex];
    }
}


function handleModeSelectKeys() {
    if (keys.ArrowLeftSelect) {
        selectedMode = 'CAREER';
        keys.ArrowLeftSelect = false; // Debounce
    }
    if (keys.ArrowRightSelect) {
        selectedMode = 'PVP';
        keys.ArrowRightSelect = false; // Debounce
    }
}

function handleCarSelectKeys(isP2) {
    const numCars = CAR_COLORS.length;
    let currentCar = isP2 ? selectedCarIndex2 : selectedCarIndex;
    let newIndex = currentCar;

    // Use specific keys for car selection based on mode
    if (isP2 || selectedMode === 'PVP') {
        if (keys.KeyA) {
            newIndex = (currentCar - 1 + numCars) % numCars;
            keys.KeyA = false;
        }
        if (keys.KeyD) {
            newIndex = (currentCar + 1) % numCars;
            keys.KeyD = false;
        }
    } 
    
    if (!isP2) { // P1 always uses arrows
        if (keys.ArrowLeftSelect) {
            newIndex = (currentCar - 1 + numCars) % numCars;
            keys.ArrowLeftSelect = false;
        }
        if (keys.ArrowRightSelect) {
            newIndex = (currentCar + 1) % numCars;
            keys.ArrowRightSelect = false;
        }
    }
    
    if (newIndex !== currentCar) {
        if (isP2) {
            selectedCarIndex2 = newIndex;
        } else {
            selectedCarIndex = newIndex;
        }
        gameMessage = ""; 
    }
}

function startCheatInput(isReset = false) {
    gameState = STATE_CHEAT_INPUT;
    cheatInput.placeholder = isReset ? "Type 'TRY AGAIN' to reset" : "Enter Code";
    cheatInput.dataset.isReset = isReset; 
    cheatInput.value = '';
    cheatInput.style.display = 'block';
    cheatInput.focus();
}

cheatInput.addEventListener('keydown', (e) => {
    if (e.code === 'Enter') {
        const code = cheatInput.value.toUpperCase().trim();
        const isResetFlow = cheatInput.dataset.isReset === 'true';
        let message = "";
        
        if (isResetFlow && code === "TRY AGAIN") {
            resetProgress();
            message = `PROGRESS RESET TO DEFAULT!`;
        } else if (code === "MONEY") {
            playerProgress.coins += CHEAT_AMOUNT;
            saveProgress();
            message = `CHEAT ACTIVATED! ${formatCurrency(CHEAT_AMOUNT)} added.`;
            playSound(1000, 0.5, 'sine', 1.0); 
        } else {
            message = "INVALID CODE.";
            playSound(100, 0.3, 'sawtooth', 0.8);
        }
        
        cheatInput.value = '';
        cheatInput.style.display = 'none';
        gameState = STATE_TITLE; 
        
        gameMessage = message;
        setTimeout(() => { gameMessage = ""; }, 3000);
        e.preventDefault(); 
    }
    if (e.code === 'Escape') {
        cheatInput.value = '';
        cheatInput.style.display = 'none';
        gameState = STATE_TITLE;
    }
    e.stopPropagation(); 
});


window.addEventListener('keydown', (e) => {
    // --- Initial setup on first interaction ---
    initAudio(); 
    loadProgress(); 
    // ------------------------------------------

    if (keys.hasOwnProperty(e.code)) keys[e.code] = true;
    
    // Only use 'ArrowLeft' and 'ArrowRight' as select keys when not in Racing state
    if (gameState !== STATE_RACING && gameState !== STATE_COUNTDOWN) {
        if (e.code === 'ArrowLeft') keys.ArrowLeftSelect = true;
        if (e.code === 'ArrowRight') keys.ArrowRightSelect = true;
    }

    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight", "Space", "Enter", "KeyW", "KeyS", "KeyA", "KeyD", "KeyR"].indexOf(e.code) > -1) e.preventDefault();

    if (gameState === STATE_TITLE) {
         if (e.code === 'KeyW') { 
             startCheatInput(false);
             return; 
         }
         if (e.code === 'KeyR') {
             startCheatInput(true);
             return;
         }
         
         if (e.code === 'Space') {
            gameState = STATE_MODE_SELECT; 
         }
    }
    else if (gameState === STATE_MODE_SELECT) {
        
        handleModeSelectKeys();

        if (e.code === 'Enter') {
            isPvP = (selectedMode === 'PVP');
            gameState = STATE_CAR_SELECT;
            gameMessage = ""; 
        }
        
        if (e.code === 'ArrowDown') {
            gameState = STATE_TITLE;
            gameMessage = "";
        }
    }
    else if (gameState === STATE_CAR_SELECT) {
        
        handleCarSelectKeys(false); // P1 Car Select
        if (isPvP) {
            handleCarSelectKeys(true); // P2 Car Select (using A/D keys)
        }

        if (e.code === 'Enter') {
            if (!isPvP) { // Career Mode Logic
                const isPurchased = playerProgress.purchasedCars.includes(selectedCarIndex);
                
                if (!isPurchased) {
                    const price = CAR_PRICES[selectedCarIndex];
                    if (playerProgress.coins >= price) {
                        playerProgress.coins -= price;
                        playerProgress.purchasedCars.push(selectedCarIndex);
                        saveProgress();
                        gameMessage = `${CAR_COLORS[selectedCarIndex].name} purchased!`;
                        playSound(700, 0.3, 'sine', 1.0);
                        setTimeout(() => { gameMessage = ""; }, 3000);
                    } else {
                        gameMessage = `NOT ENOUGH COINS! Price: ${formatCurrency(price)}.`;
                        playSound(100, 0.3, 'sawtooth', 0.8);
                        setTimeout(() => { gameMessage = ""; }, 3000);
                    }
                    return;
                } else {
                    // Car is owned, proceed to next state
                    gameState = STATE_DIFFICULTY; 
                }
            } else { // PvP Mode Logic
                 if (selectedCarIndex === selectedCarIndex2) {
                     gameMessage = `Players must choose different cars!`;
                     setTimeout(() => { gameMessage = ""; }, 3000);
                     return;
                 }
                 gameState = STATE_TRACK_SELECT; 
            }
        }
        
        if (e.code === 'ArrowDown') {
            gameState = STATE_MODE_SELECT;
            gameMessage = "";
        }
    }
    else if (gameState === STATE_DIFFICULTY) {
        handleDifficultySelectKeys();
        if (e.code === 'Enter') { 
            gameState = STATE_TRACK_SELECT;
        }
        if (e.code === 'ArrowDown') { 
            gameState = STATE_CAR_SELECT;
            gameMessage = "";
        }
    }
    else if (gameState === STATE_TRACK_SELECT) {
        handleTrackSelectKeys();
        if (e.code === 'Enter') { 
            startFrame = frameCount; 
            startRaceSequence();
        }
        if (e.code === 'ArrowDown') { 
            gameState = isPvP ? STATE_CAR_SELECT : STATE_DIFFICULTY;
            gameMessage = "";
        }
    }
    
    else if (gameState === STATE_GAMEOVER || gameState === STATE_FALSE_START) {
        if (e.code === 'Space' && showRestart) resetGame();
    }

    if (gameState === STATE_RACING) {
        if (e.code === 'ArrowUp') player.shift(1);
        if (e.code === 'ArrowDown') player.shift(-1);
        
        if (isPvP) {
            if (e.code === 'KeyW') player2.shift(1);
            if (e.code === 'KeyS') player2.shift(-1);
        }
    }
});

window.addEventListener('keyup', (e) => {
    if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
    
    if (e.code === 'ArrowLeft') keys.ArrowLeftSelect = false;
    if (e.code === 'ArrowRight') keys.ArrowRightSelect = false;
    if (e.code === 'KeyA') keys.KeyA = false;
    if (e.code === 'KeyD') keys.KeyD = false;
    
    // --- Launch Controls ---
    if (gameState === STATE_COUNTDOWN) {
        // Player 1 Launch
        if (e.code === 'ArrowLeft' && keys.ArrowRight) {
             // Do nothing yet, wait for RIGHT keyup to avoid double trigger
        }
        if (e.code === 'ArrowRight' || e.code === 'ArrowLeft') {
            if (!keys.ArrowLeft && !keys.ArrowRight) { // Both keys released
                if (lightsState === 5) {
                    player.isReadyToLaunch = true;
                    player.updatePlayerTargets(); 
                    playSound(300, 0.2, 'square', 1.0);
                    if (raceStartTime === 0) raceStartTime = performance.now();
                } else if (lightsState >= 1 && lightsState <= 4) {
                    endGame(player, "P1 FALSE START!");
                }
            }
        }
        
        // Player 2 Launch (Key A/D)
        if (isPvP) {
             if (e.code === 'KeyA' && keys.KeyD) {
                 // Do nothing yet
             }
             if (e.code === 'KeyD' || e.code === 'KeyA') {
                 if (!keys.KeyA && !keys.KeyD) { // Both keys released
                    if (lightsState === 5) {
                        player2.isReadyToLaunch = true;
                        player2.updatePlayerTargets(); 
                        playSound(300, 0.2, 'square', 1.0);
                        if (raceStartTime === 0) raceStartTime = performance.now();
                    } else if (lightsState >= 1 && lightsState <= 4) {
                        endGame(player2, "P2 FALSE START!");
                    }
                 }
            }
        }
    }
});


// --- HELPER FUNCTIONS ---

function resetGame() {
    stopEngineSound();
    player.reset();
    cpu.reset();
    player2.reset();
    
    gameState = STATE_MODE_SELECT;
    
    lightsState = 0;
    winnerText = "";
    showRestart = false;
    treeScrollPosition = 0;
    raceStartTime = 0;
    raceFinishTime = 0;
    raceFinishTime2 = 0;
    liveRaceTime = 0;
    gameMessage = "";
    finishedPlayers = [];
}

function endGame(winnerOrFalseStarter, message = "") {
    
    if (message.includes("FALSE START")) {
        winnerText = message;
        gameState = STATE_FALSE_START;
        stopEngineSound();
        playSound(100, 0.8, 'sawtooth', 0.8);
        setTimeout(() => { showRestart = true; }, 1000);
        return;
    }
    
    if (!isPvP) {
        gameState = STATE_GAMEOVER;
        stopEngineSound();
        
        raceFinishTime = performance.now();
        
        const payout = RACE_PAYOUTS[difficulty];
        let moneyChange = 0;
        let resultMessage = "";

        if (winnerOrFalseStarter === player) {
            winnerText = `P1 WINNER (${player.name})`;
            moneyChange = payout;
            playerProgress.coins += moneyChange;
            resultMessage = `ðŸ’° YOU WON! +${formatCurrency(moneyChange)}`;
            playSound(800, 0.5, 'sine', 1.0);
        } else {
            winnerText = `CPU LOSER (${cpu.name})`;
            const cost = RACE_COSTS[difficulty];
            moneyChange = cost * -1; // Reflect entry fee loss
            resultMessage = `ðŸ’¸ ENTRY LOST: ${formatCurrency(cost)}`;
            playSound(200, 0.5, 'sawtooth', 0.8);
        }

        saveProgress();
        if (moneyChange !== 0) winnerText += `\n${resultMessage}`;
        
    } else {
        if (winnerOrFalseStarter === player) {
            if (raceFinishTime === 0) raceFinishTime = performance.now();
            finishedPlayers.push(player.name);
        } else if (winnerOrFalseStarter === player2) {
            if (raceFinishTime2 === 0) raceFinishTime2 = performance.now();
            finishedPlayers.push(player2.name);
        }
        
        if (finishedPlayers.length === 2) {
             const finalWinner = (raceFinishTime < raceFinishTime2) ? player : player2;
             winnerText = finalWinner.isPlayer ? "P1 WINS!" : "P2 WINS!";
             gameState = STATE_GAMEOVER;
             stopEngineSound();
             playSound(800, 0.5, 'sine', 1.0);
        }
    }

    setTimeout(() => { showRestart = true; }, 2000);
}

// --- DRAWING FUNCTIONS ---

/**
 * Draws a unique car shape based on its shapeIndex.
 * @param {number} x The screen X coordinate.
 * @param {number} y The screen Y coordinate (top of body).
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {string} color Main body color.
 * @param {string} accentColor Window/detail color.
 * @param {number} shapeIndex Index defining the car's body shape.
 * @param {boolean} isPreview If true, draws larger wheels for the garage view.
 */
function drawSelectedCarShape(x, y, w, h, color, accentColor, shapeIndex, isPreview) {
    ctx.fillStyle = color;
    ctx.strokeStyle = accentColor;
    ctx.lineWidth = isPreview ? 4 : 3;

    ctx.beginPath();
    
    // --- Unique Car Shapes based on shapeIndex ---
    if (shapeIndex === 0) { // Default/Mustang
        ctx.fillRect(x, y, w, h);
        ctx.fillStyle = accentColor; ctx.fillRect(x + w * 0.1, y, w * 0.13, h/2);
        ctx.fillStyle = color;
        ctx.fillRect(x + w * 0.25, y, w * 0.5, h/2);
    } else if (shapeIndex === 1) { // Civic/Hatchback
        ctx.moveTo(x + w * 0.1, y);
        ctx.lineTo(x + w, y);
        ctx.lineTo(x + w, y + h);
        ctx.lineTo(x, y + h);
        ctx.lineTo(x, y + h * 0.7);
        ctx.lineTo(x + w * 0.1, y);
        ctx.fill();
        ctx.fillStyle = accentColor; ctx.fillRect(x + w * 0.6, y, w * 0.3, h * 0.4);
    } else if (shapeIndex === 2) { // Supra/Sporty Coupe
        ctx.moveTo(x, y + h * 0.8);
        ctx.lineTo(x + w, y + h);
        ctx.lineTo(x + w - 10, y);
        ctx.lineTo(x + 20, y);
        ctx.lineTo(x, y + h * 0.8);
        ctx.fill();
        ctx.fillStyle = accentColor; ctx.fillRect(x + 30, y, w - 60, h * 0.3);
    } else if (shapeIndex === 3) { // Corvette/Low Profile
        ctx.moveTo(x, y + h * 0.5);
        ctx.lineTo(x + 10, y);
        ctx.lineTo(x + w, y + h * 0.5);
        ctx.lineTo(x + w - 10, y + h);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = accentColor; ctx.fillRect(x + w * 0.3, y + h * 0.1, w * 0.5, h * 0.2);
    } else if (shapeIndex === 4) { // NSX/Mid-Engine Wedge
        ctx.moveTo(x, y + h);
        ctx.lineTo(x + w, y + h);
        ctx.lineTo(x + w, y + h * 0.3);
        ctx.lineTo(x + w * 0.1, y);
        ctx.lineTo(x, y + h);
        ctx.fill();
        ctx.fillStyle = accentColor; ctx.fillRect(x + w * 0.7, y + h * 0.4, w * 0.2, h * 0.3);
    } else if (shapeIndex === 5) { // GTR/Blocky Muscle
        ctx.fillRect(x, y, w, h);
        ctx.fillStyle = accentColor; 
        ctx.fillRect(x + w * 0.8, y, w * 0.2, h);
    } else if (shapeIndex === 6) { // Lamborghini/Sharp Wedge
        ctx.moveTo(x, y + h);
        ctx.lineTo(x + w, y + h);
        ctx.lineTo(x + w * 0.8, y);
        ctx.lineTo(x + w * 0.2, y);
        ctx.lineTo(x, y + h);
        ctx.fill();
        ctx.fillStyle = accentColor; ctx.fillRect(x + w * 0.25, y + h * 0.1, w * 0.5, h * 0.1);
    } else if (shapeIndex === 7) { // Pagani/Rounded Roof
        ctx.fillRect(x, y + h * 0.2, w, h * 0.8);
        ctx.beginPath();
        ctx.arc(x + w * 0.5, y + h * 0.2, w * 0.25, Math.PI, 0);
        ctx.fill();
        ctx.fillStyle = accentColor; ctx.fillRect(x + 5, y + 5, 20, 20);
    } else if (shapeIndex === 8) { // Ferrari/Curved Sport
        ctx.fillRect(x, y + h * 0.4, w, h * 0.6);
        ctx.beginPath();
        ctx.arc(x + w * 0.4, y + h * 0.4, w * 0.35, Math.PI, 0);
        ctx.fill();
        ctx.fillStyle = accentColor; ctx.fillRect(x + w * 0.3, y + h * 0.1, w * 0.4, h * 0.2);
    } else if (shapeIndex === 9) { // Bugatti/Two-Tone Split
        ctx.fillRect(x, y, w, h);
        ctx.fillStyle = accentColor;
        ctx.fillRect(x + w * 0.3, y, w * 0.4, h);
        ctx.fillStyle = color;
        ctx.fillRect(x + w * 0.3 + 5, y + 5, w * 0.4 - 10, h - 10);
    }
    
    // Wheels 
    const wheelRadius = isPreview ? 15 : 10;
    const wheelY = isPreview ? y + h + 5 : y + h - 10;
    const wheelColor = isPreview ? "#222" : "#000";

    // Front Wheel
    ctx.fillStyle = wheelColor;
    ctx.fillRect(x + wheelRadius * 0.5, wheelY, wheelRadius * 2, wheelRadius);

    // Rear Wheel
    ctx.fillRect(x + w - wheelRadius * 2.5, wheelY, wheelRadius * 2, wheelRadius);
}

function drawLockIcon(x, y) {
    ctx.fillStyle = "#FF0";
    ctx.fillRect(x, y, 30, 30); // Body of the lock
    ctx.fillRect(x + 5, y + 30, 20, 5); // Bottom section
    
    ctx.fillStyle = "#A00";
    ctx.fillRect(x + 10, y + 5, 10, 25);
    
    ctx.strokeStyle = "#FF0";
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.arc(x + 15, y - 5, 10, Math.PI, 0);
    ctx.stroke();
}


function drawSkyAndGround() {
    ctx.fillStyle = "#87CEEB";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const treePixelDistance = 70;
    const treeMeterDistance = 10 * 0.3048; 

    const pixelsPerMeter = treePixelDistance / treeMeterDistance;
    const scrollRate = player.speed * 0.016 * pixelsPerMeter; 
    
    treeScrollPosition += scrollRate;
    
    const baseOffset = treeScrollPosition % (treePixelDistance * 2);

    const numTrees = Math.ceil(canvas.width / treePixelDistance) + 5;
    
    for(let i = 0; i < numTrees; i++) { 
        let tx = (i * treePixelDistance * 2) - baseOffset - 100;

        if (tx > -100 && tx < canvas.width + 100) {
            ctx.fillStyle = "#8B4513"; ctx.fillRect(tx + 25, 250, 20, 50);
            ctx.fillStyle = "#006400"; ctx.fillRect(tx, 220, 70, 30); ctx.fillRect(tx + 15, 180, 40, 40);
            
            let tx2 = tx + treePixelDistance;
            ctx.fillStyle = "#8B4513"; ctx.fillRect(tx2 + 25, 250, 20, 50);
            ctx.fillStyle = "#006400"; ctx.fillRect(tx2, 220, 70, 30); ctx.fillRect(tx2 + 15, 180, 40, 40);
        }
    }

    ctx.fillStyle = "#555";
    ctx.fillRect(0, 300, canvas.width, 240); 
    
    ctx.strokeStyle = "#FFF"; ctx.lineWidth = 4; ctx.setLineDash([40, 40]);
    ctx.beginPath(); ctx.moveTo(0 - (cameraX % 80), 420); ctx.lineTo(canvas.width, 420); ctx.stroke(); 
    
    if (isPvP) {
        ctx.strokeStyle = "#000"; ctx.lineWidth = 4; ctx.setLineDash([40, 40]);
        ctx.beginPath(); ctx.moveTo(0 - (cameraX % 80), 340); ctx.lineTo(canvas.width, 340); ctx.stroke();
    }
    
    ctx.setLineDash([]);

    let finishScreenX = 50 + (TRACK_LENGTH * 10) - cameraX;
    if (finishScreenX > -100 && finishScreenX < canvas.width) {
        ctx.fillStyle = "#FFF"; ctx.fillRect(finishScreenX, 200, 10, 340);
        ctx.fillStyle = "#000"; ctx.fillRect(finishScreenX - 30, 200, 70, 40);
        ctx.fillStyle = "#FFF"; ctx.font = "10px 'Press Start 2P'"; 
        
        let trackLabel = selectedTrack.replace('_MILE', ' MILE').replace('QUARTER', '1/4');
        ctx.fillText("FINISH (" + trackLabel + ")", finishScreenX - 25, 225);
    }
}

function drawHUD() {
    ctx.fillStyle = "#1a1a1a";
    ctx.fillRect(0, 0, canvas.width, 90);
    ctx.strokeStyle = "#444"; ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(0, 90); ctx.lineTo(canvas.width, 90); ctx.stroke();
    
    let mph = player.speed * MS_TO_MPH;
    // P1 MPH
    drawGauge(150, 45, "MPH (P1)", mph, 300, false); 
    // P1 RPM - MOVED LEFT
    drawGauge(canvas.width/2 - 100, 45, "RPM (P1)", player.rpm, MAX_RPM_DISPLAY, true);
    
    // P1 GEAR BOX
    ctx.fillStyle = "#000";
    ctx.fillRect(canvas.width/2 - 40, 15, 80, 60);
    ctx.strokeStyle = "#FFD700";
    ctx.strokeRect(canvas.width/2 - 40, 15, 80, 60);
    
    ctx.fillStyle = "#FFD700";
    ctx.font = "40px 'Press Start 2P'";
    ctx.textAlign = "center";
    ctx.fillText(player.gear, canvas.width/2, 60);
    ctx.font = "10px 'Press Start 2P'";
    ctx.fillText("P1 GEAR", canvas.width/2, 85);
    
    if (isPvP) {
        let mph2 = player2.speed * MS_TO_MPH;
        // P2 RPM - MOVED LEFT
        drawGauge(canvas.width/2 + 100, 45, "RPM (P2)", player2.rpm, MAX_RPM_DISPLAY, true);
        // P2 MPH
        drawGauge(canvas.width - 150, 45, "MPH (P2)", mph2, 300, false);
        
        // P2 GEAR BOX
        ctx.fillStyle = "#000";
        ctx.fillRect(canvas.width/2 - 40, 100, 80, 40);
        ctx.strokeStyle = "#00FF00";
        ctx.strokeRect(canvas.width/2 - 40, 100, 80, 40);
        ctx.fillStyle = "#00FF00";
        ctx.font = "20px 'Press Start 2P'";
        ctx.fillText(player2.gear, canvas.width/2, 125);
        ctx.font = "8px 'Press Start 2P'";
        ctx.fillText("P2 GEAR", canvas.width/2, 145);
    }

    ctx.fillStyle = "#0F0";
    ctx.font = "12px 'Press Start 2P'";
    ctx.textAlign = "left";
    ctx.fillText(`COINS: ${formatCurrency(playerProgress.coins)}`, 20, 20);

    if (gameState === STATE_RACING && raceStartTime > 0) {
        liveRaceTime = (performance.now() - raceStartTime) / 1000;
        let timeDisplay = liveRaceTime.toFixed(3);
        
        ctx.fillStyle = "#FFF";
        ctx.font = "15px 'Press Start 2P'";
        ctx.textAlign = "right";
        ctx.fillText("TIME: " + timeDisplay, canvas.width - 20, 110);
        
        if (isPvP) {
             let p1Time = raceFinishTime > 0 ? ((raceFinishTime - raceStartTime) / 1000).toFixed(3) : "RACING";
             let p2Time = raceFinishTime2 > 0 ? ((raceFinishTime2 - raceStartTime) / 1000).toFixed(3) : "RACING";
             ctx.fillText(`P1: ${p1Time}`, canvas.width - 20, 130);
             ctx.fillText(`P2: ${p2Time}`, canvas.width - 20, 150);
        }
    }

    if (player.penaltyFactor < 1.0) {
        ctx.fillStyle = "red";
        ctx.font = "10px 'Press Start 2P'";
        ctx.textAlign = "center";
        ctx.fillText("P1 PENALTY", canvas.width/2, 105);
    }
    if (isPvP && player2.penaltyFactor < 1.0) {
        ctx.fillStyle = "red";
        ctx.font = "10px 'Press Start 2P'";
        ctx.textAlign = "center";
        ctx.fillText("P2 PENALTY", canvas.width/2, 160);
    }
}

function drawGauge(x, y, label, value, max, isRPM) {
    ctx.beginPath();
    ctx.arc(x, y + 20, 50, Math.PI, 0); 
    ctx.fillStyle = "#000"; ctx.fill();
    ctx.lineWidth = 2; ctx.strokeStyle = "#FFF"; ctx.stroke();
    
    if (isRPM) {
        let redStartAngle = Math.PI + (SHIFT_POINT_RPM / max * Math.PI);
        ctx.beginPath();
        ctx.arc(x, y + 20, 46, redStartAngle, 0); 
        ctx.lineWidth = 8; ctx.strokeStyle = "red"; ctx.stroke();
        
        let yellowStartAngle = Math.PI + (OPTIMAL_SHIFT_START_RPM / max * Math.PI);
        ctx.beginPath();
        ctx.arc(x, y + 20, 46, yellowStartAngle, redStartAngle);
        ctx.lineWidth = 8; ctx.strokeStyle = "yellow"; ctx.stroke();
    }
    
    let percent = value / max;
    if (percent > 1.1) percent = 1.1; 
    let angle = Math.PI + (percent * Math.PI);
    let tipX = x + Math.cos(angle) * 45;
    let tipY = (y + 20) + Math.sin(angle) * 45;
    ctx.beginPath(); ctx.moveTo(x, y + 20); ctx.lineTo(tipX, tipY);
    ctx.strokeStyle = "red"; ctx.lineWidth = 3; ctx.stroke();
    ctx.fillStyle = "#FFF";
    ctx.font = "12px 'Press Start 2P'";
    ctx.textAlign = "center";
    ctx.fillText(Math.floor(value), x, y + 55);
    ctx.font = "10px 'Press Start 2P'";
    ctx.fillText(label, x, y - 40);
}

function drawLights() {
    let bx = canvas.width / 2 - 40;
    let by = 160;
    
    ctx.fillStyle = "#000"; ctx.fillRect(bx, by, 80, 220); ctx.strokeStyle = "#444"; ctx.strokeRect(bx, by, 80, 220);

    function drawBulb(index, color, active) {
        let cy = by + 25 + (index * 40);
        ctx.beginPath();
        ctx.arc(bx + 40, cy, 15, 0, Math.PI*2);
        if (active) {
            ctx.fillStyle = color;
            ctx.shadowBlur = 20; ctx.shadowColor = color;
            ctx.fill();
            ctx.shadowBlur = 0;
        } else {
            ctx.fillStyle = "#222"; 
            ctx.fill();
            ctx.strokeStyle = "#555";
            ctx.stroke();
        }
    }

    drawBulb(0, "#F00", lightsState === 1); 
    drawBulb(1, "#FF0", lightsState === 2); 
    drawBulb(2, "#FF0", lightsState === 3); 
    drawBulb(3, "#FF0", lightsState === 4); 
    drawBulb(4, "#0F0", lightsState === 5); 
    
    if (lightsState === 5) {
        ctx.fillStyle = "#0F0";
        ctx.font = "80px 'Press Start 2P'";
        ctx.textAlign = "center";
        ctx.fillText("GO!", canvas.width/2, 140);
    }
    
    if (gameState === STATE_COUNTDOWN) {
        let p1Prompt = "P1: Hold <- + ->";
        let p2Prompt = isPvP ? "P2: Hold A + D" : "CPU ON GREEN";
        let p1Status = (keys.ArrowLeft && keys.ArrowRight) ? "READY!" : "";
        let p2Status = (keys.KeyA && keys.KeyD) ? "READY!" : "";

        ctx.fillStyle = "#FFF";
        ctx.font = "12px 'Press Start 2P'";
        ctx.fillText(p1Prompt, canvas.width/2, by + 230);
        ctx.fillText(p2Prompt, canvas.width/2, by + 250);
        
        ctx.fillStyle = "#FF0";
        ctx.fillText(p1Status, canvas.width/2 - 100, by + 230);
        if (isPvP) ctx.fillText(p2Status, canvas.width/2 - 100, by + 250);
    }
}

function drawCarSelect() {
    ctx.fillStyle = "#333"; ctx.fillRect(0, 0, canvas.width, canvas.height); // Dark background
    
    // --- Pixelated Garage ---
    ctx.fillStyle = "#444"; // Wall
    ctx.fillRect(0, 0, canvas.width, 150);
    ctx.fillStyle = "#666"; // Floor
    ctx.fillRect(0, 150, canvas.width, canvas.height - 150);
    
    // Workbench/Tools
    ctx.fillStyle = "#800"; ctx.fillRect(20, 100, 150, 50); // Workbench
    ctx.fillStyle = "#0F0"; ctx.fillRect(30, 80, 20, 20); // Tool box 1
    ctx.fillStyle = "#00F"; ctx.fillRect(60, 80, 20, 20); // Tool box 2
    
    // Window
    ctx.fillStyle = "#ADD8E6"; ctx.fillRect(canvas.width - 180, 20, 150, 80);
    ctx.strokeStyle = "#222"; ctx.lineWidth = 4; ctx.strokeRect(canvas.width - 180, 20, 150, 80);

    // Spotlight
    ctx.fillStyle = "rgba(255, 255, 0, 0.1)";
    ctx.beginPath();
    ctx.moveTo(canvas.width/2, 150);
    ctx.lineTo(canvas.width/2 + 200, canvas.height);
    ctx.lineTo(canvas.width/2 - 200, canvas.height);
    ctx.closePath();
    ctx.fill();
    // -------------------------

    let car1Data = CAR_COLORS[selectedCarIndex];
    let car1Owned = playerProgress.purchasedCars.includes(selectedCarIndex);
    let car1Price = CAR_PRICES[selectedCarIndex];
    
    // --- P1 CAR PREVIEW (Center) ---
    let p1X = isPvP ? canvas.width * 0.25 : canvas.width * 0.5;
    
    // Large Border/Display Box
    ctx.strokeStyle = car1Owned ? "#0F0" : "red";
    ctx.lineWidth = 8;
    ctx.strokeRect(p1X - 250, 150, 500, 300);

    // Draw the Car
    const carW = 300;
    const carH = 80;
    const carDrawX = p1X - carW/2;
    const carDrawY = 320; 
    drawSelectedCarShape(carDrawX, carDrawY, carW, carH, car1Data.color, car1Data.accentColor, car1Data.shapeIndex, true);
    
    // Car Name and Stats
    ctx.fillStyle = "white";
    ctx.font = "20px 'Press Start 2P'";
    ctx.textAlign = "center";
    ctx.fillText(`P1: ${car1Data.name}`, p1X, 200);
    
    ctx.font = "15px 'Press Start 2P'";
    ctx.fillStyle = car1Data.accentColor;
    ctx.fillText(`Acceleration: ${10 - car1Data.accelerationIndex}/10`, p1X, 240);

    if (!isPvP) { // Career Mode specific info
        if (!car1Owned) {
            // Lock and Price
            drawLockIcon(p1X + 180, 170);
            ctx.fillStyle = "red";
            ctx.font = "18px 'Press Start 2P'";
            ctx.fillText(`PRICE: ${formatCurrency(car1Price)}`, p1X, 470);
            ctx.fillStyle = "white";
            ctx.font = "15px 'Press Start 2P'";
            ctx.fillText("Press ENTER to BUY", p1X, 510);
        } else {
            // Unlocked message and proceed
            ctx.fillStyle = "#0F0";
            ctx.font = "18px 'Press Start 2P'";
            ctx.fillText("OWNED", p1X, 470);
            ctx.fillStyle = "white";
            ctx.font = "15px 'Press Start 2P'";
            ctx.fillText("Press ENTER to SELECT", p1X, 510);
        }
        
        ctx.fillStyle = "white";
        ctx.font = "10px 'Press Start 2P'";
        ctx.fillText("Use Arrows to Change", p1X, 170);
        
    } else { // PvP Mode Info
        // --- P2 CAR PREVIEW (Right) ---
        let car2Data = CAR_COLORS[selectedCarIndex2];
        let p2X = canvas.width * 0.75;
        let differentCars = selectedCarIndex !== selectedCarIndex2;
        
        // P2 Display Box (smaller)
        ctx.strokeStyle = differentCars ? "#00FFFF" : "red";
        ctx.lineWidth = 4;
        ctx.strokeRect(p2X - 100, 150, 200, 150);
        
        // Draw the Car
        const car2W = 150;
        const car2H = 40;
        const car2DrawX = p2X - car2W/2;
        const car2DrawY = 220; 
        drawSelectedCarShape(car2DrawX, car2DrawY, car2W, car2H, car2Data.color, car2Data.accentColor, car2Data.shapeIndex, false);

        // P2 Name and Stats
        ctx.fillStyle = "white";
        ctx.font = "12px 'Press Start 2P'";
        ctx.textAlign = "center";
        ctx.fillText(`P2: ${car2Data.name}`, p2X, 170);
        ctx.fillText(`ACCEL: ${10 - car2Data.accelerationIndex}/10`, p2X, 190);
        
        ctx.font = "10px 'Press Start 2P'";
        ctx.fillStyle = "#00FFFF";
        ctx.fillText("P2: A/D to Change", p2X, 320);

        ctx.fillStyle = "white";
        ctx.font = "15px 'Press Start 2P'";
        if (differentCars) {
             ctx.fillText("Press ENTER to RACE", canvas.width/2, 510);
        } else {
             ctx.fillStyle = "red";
             ctx.fillText("P1 and P2 Cars Must Be Different!", canvas.width/2, 510);
        }
    }
    
    // Global HUD and Message
    ctx.fillStyle = "white"; 
    ctx.font = "15px 'Press Start 2P'";
    ctx.textAlign = "left";
    ctx.fillText(`COINS: ${formatCurrency(playerProgress.coins)}`, 20, 40);
    ctx.textAlign = "center";
    
    if (gameMessage) {
        ctx.fillStyle = gameMessage.includes('NOT ENOUGH') || gameMessage.includes('DIFFERENT') ? "red" : "#0F0";
        ctx.font = "15px 'Press Start 2P'";
        ctx.fillText(gameMessage, canvas.width/2, 45);
    }
    
    ctx.font = "10px 'Press Start 2P'";
    ctx.fillStyle = "white";
    ctx.fillText("Press Down Arrow to Go Back to Mode Select.", canvas.width/2, canvas.height - 10);
}


// --- GAME LOOP ---

function update() {
    frameCount++;
    // Update engine sound using P1's RPM, or P2's if P1 is idle in PvP
    const activeRpm = isPvP && player.rpm < IDLE_RPM + 100 && player2.rpm > IDLE_RPM + 100 ? player2.rpm : player.rpm;
    updateEngineSound(activeRpm, gameState);

    if (gameState === STATE_COUNTDOWN) {
        let diff = frameCount - startFrame;
        let lastLightsState = lightsState;

        if (diff < 60) lightsState = 1;
        else if (diff < 90) lightsState = 2;
        else if (diff < 120) lightsState = 3;
        else if (diff < 150) lightsState = 4;
        else if (diff < 180) {
            lightsState = 5; 
        } else {
            if (!player.isReadyToLaunch) {
                 player.isReadyToLaunch = true;
                 player.updatePlayerTargets();
                 if (raceStartTime === 0) raceStartTime = performance.now();
            }
            if (isPvP && !player2.isReadyToLaunch) {
                 player2.isReadyToLaunch = true;
                 player2.updatePlayerTargets();
                 if (raceStartTime === 0) raceStartTime = performance.now();
            }
            
            gameState = STATE_RACING;
            lightsState = 0; 
        }

        if (lightsState > 1 && lightsState !== lastLightsState && lightsState <= 4) {
            playSound(400 + lightsState * 50, 0.1, 'sine', 0.5);
        } else if (lightsState === 5 && lastLightsState === 4) {
            playSound(600, 0.2, 'sine', 1.0);
        }

        if (keys.ArrowLeft && keys.ArrowRight) {
            player.rpm = 8000 + Math.sin(frameCount * 0.1) * 500;
        } else if (lightsState >= 1 && lightsState <= 5) {
            player.rpm = IDLE_RPM;
        }
        
        if (isPvP && keys.KeyA && keys.KeyD) {
            player2.rpm = 8000 + Math.sin(frameCount * 0.1) * 500;
        } else if (isPvP && lightsState >= 1 && lightsState <= 5) {
            player2.rpm = IDLE_RPM;
        }
    }
    else if (gameState === STATE_RACING) {
        if (frameCount - startFrame < 210) lightsState = 5;
        else lightsState = 0;

        player.update();
        if (!isPvP) cpu.update();
        if (isPvP) player2.update();

        cameraX = (player.distance * 10) - 100;
        if (cameraX < 0) cameraX = 0;

        const racers = isPvP ? [player, player2] : [player, cpu];
        
        racers.forEach(racer => {
            if (racer.distance >= TRACK_LENGTH && !finishedPlayers.includes(racer.name)) {
                
                if (!isPvP) {
                    endGame(racer, "");
                } else {
                    if (racer === player) {
                        endGame(player);
                    } else if (racer === player2) {
                        endGame(player2);
                    }
                }
            }
        });
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (gameState !== STATE_CHEAT_INPUT) {
         cheatInput.style.display = 'none';
    }

    if (gameState === STATE_TITLE) {
        ctx.fillStyle = "#87CEEB"; ctx.fillRect(0,0, canvas.width, canvas.height);
        ctx.fillStyle = "#FFD700"; ctx.font = "40px 'Press Start 2P'"; ctx.textAlign = "center";
        ctx.fillText("SUPER DRAG RACERS", canvas.width/2, 150);
        ctx.font = "20px 'Press Start 2P'"; ctx.fillStyle = "white";
        ctx.fillText("Universal Shift Edition", canvas.width/2, 190);
        
        ctx.fillStyle = "red"; ctx.fillRect(canvas.width/2 - 100, 250, 200, 50);
        ctx.fillStyle = "black"; ctx.fillRect(canvas.width/2 - 80, 290, 40, 40); ctx.fillRect(canvas.width/2 + 40, 290, 40, 40);
        
        if (Math.floor(frameCount / 30) % 2 === 0) {
            ctx.fillStyle = "white"; ctx.fillText("PRESS SPACE BAR TO START", canvas.width/2, 400);
        }

        if (gameMessage) {
            ctx.fillStyle = gameMessage.includes('ACTIVATED') || gameMessage.includes('RESET') ? "#0F0" : "red";
            ctx.font = "15px 'Press Start 2P'";
            ctx.fillText(gameMessage, canvas.width/2, 450);
        }
        
        ctx.fillStyle = "white"; ctx.font = "10px 'Press Start 2P'";
        ctx.fillText("Press W for Cheats / R for Reset", canvas.width/2, 500);
    }
    else if (gameState === STATE_CHEAT_INPUT) {
        ctx.fillStyle = "rgba(0,0,0,0.9)"; ctx.fillRect(0,0, canvas.width, canvas.height);
        ctx.fillStyle = "white"; ctx.font = "30px 'Press Start 2P'"; ctx.textAlign = "center";
        ctx.fillText("DEVELOPER CONSOLE", canvas.width/2, 150);
        ctx.font = "15px 'Press Start 2P'";
        ctx.fillText(cheatInput.placeholder, canvas.width/2, 200);
        ctx.fillText("Press ESC to exit", canvas.width/2, 500);
    }
    else if (gameState === STATE_MODE_SELECT) {
        ctx.fillStyle = "#222"; ctx.fillRect(0,0, canvas.width, canvas.height);
        ctx.fillStyle = "white"; ctx.font = "30px 'Press Start 2P'"; ctx.textAlign = "center";
        ctx.fillText("SELECT GAME MODE", canvas.width/2, 80);
        
        let careerX = canvas.width * 0.25;

        // CAREER MODE BOX
        ctx.fillStyle = "#0F0";
        ctx.fillRect(careerX - 150, 150, 300, 350);
        if (selectedMode === 'CAREER') {
             ctx.strokeStyle = "#FFD700"; ctx.lineWidth = 5;
             ctx.strokeRect(careerX - 150, 150, 300, 350);
        }
        ctx.fillStyle = "black";
        ctx.font = "20px 'Press Start 2P'";
        ctx.fillText("CAREER MODE", careerX, 180);
        ctx.font = "12px 'Press Start 2P'";
        ctx.fillText("PLAYER VS CPU", careerX, 210);
        ctx.fillText("Unlock Cars & Earn Coins", careerX, 240);
        ctx.fillText("P1: Use Arrows", careerX, 270);
        
        // PVP MODE BOX
        let pvpX = canvas.width * 0.75;
        ctx.fillStyle = "#00FFFF";
        ctx.fillRect(pvpX - 150, 150, 300, 350);
        if (selectedMode === 'PVP') {
             ctx.strokeStyle = "#FFD700"; ctx.lineWidth = 5;
             ctx.strokeRect(pvpX - 150, 150, 300, 350);
        }
        ctx.fillStyle = "black";
        ctx.font = "20px 'Press Start 2P'";
        ctx.fillText("2-PLAYER PVP", pvpX, 180);
        ctx.font = "12px 'Press Start 2P'";
        ctx.fillText("P1 (Arrows) vs P2 (WASD)", pvpX, 210);
        ctx.fillText("Race for Bragging Rights", pvpX, 240);
        ctx.fillText("P2: Use WASD", pvpX, 270);


        ctx.fillStyle = "white"; 
        ctx.font = "15px 'Press Start 2P'";
        ctx.fillText(`COINS: ${formatCurrency(playerProgress.coins)}`, canvas.width/2, 40);
        
        ctx.fillText("Use Left/Right Arrows to select mode", canvas.width/2, 450);
        ctx.fillText("Press ENTER to select.", canvas.width/2, 480);
        ctx.fillText("Press Down Arrow to Go Back to Title.", canvas.width/2, 510);
        
    }
    else if (gameState === STATE_CAR_SELECT) {
        drawCarSelect();
    }
    else if (gameState === STATE_DIFFICULTY) {
        ctx.fillStyle = "#222"; ctx.fillRect(0,0, canvas.width, canvas.height);
        ctx.fillStyle = "white"; ctx.font = "30px 'Press Start 2P'"; ctx.textAlign = "center";
        ctx.fillText("SELECT DIFFICULTY", canvas.width/2, 100);
        
        const optionColors = {
            'EASY': "#0F0", 'MEDIUM': "#FF0", 'HARD': "#F00", 
            'EXPERT': "#00F", 'LEGEND': "#800080" 
        };
        const optionTextColors = {
            'EASY': "black", 'MEDIUM': "black", 'HARD': "white", 
            'EXPERT': "white", 'LEGEND': "white" 
        };
        const numOptions = DIFFICULTY_OPTIONS.length;
        const spacing = canvas.width / (numOptions + 1);

        for (let i = 0; i < numOptions; i++) {
            const level = DIFFICULTY_OPTIONS[i];
            const xCenter = spacing * (i + 1);
            const isSelected = level === difficulty;
            const bgColor = optionColors[level];
            const fgColor = optionTextColors[level];
            const cost = RACE_COSTS[level];

            ctx.fillStyle = isSelected ? bgColor : "#555";
            ctx.fillRect(xCenter - 70, 220, 140, 90); 
            
            ctx.font = "12px 'Press Start 2P'";
            ctx.fillStyle = isSelected ? fgColor : "white";
            ctx.fillText(level, xCenter, 245);

            ctx.font = "10px 'Press Start 2P'";
            ctx.fillStyle = isSelected ? fgColor : "white";
            ctx.fillText(`$${cost.toLocaleString('en-US')}`, xCenter, 270);
            
            const payout = RACE_PAYOUTS[level];
            ctx.font = "8px 'Press Start 2P'";
            ctx.fillStyle = isSelected ? fgColor : "#0F0";
            ctx.fillText(`WIN: $${payout.toLocaleString('en-US')}`, xCenter, 295);
        }
        
        ctx.font = "15px 'Press Start 2P'"; ctx.fillStyle = "white";
        ctx.fillText("Balance: " + formatCurrency(playerProgress.coins), canvas.width/2, 400);
        ctx.fillText("Use Left/Right Arrows, Press ENTER to Continue", canvas.width/2, 430);
        ctx.fillText("Press Down Arrow to go Back to Car Select.", canvas.width/2, 480);
    }
    else if (gameState === STATE_TRACK_SELECT) {
        ctx.fillStyle = "#222"; ctx.fillRect(0,0, canvas.width, canvas.height);
        ctx.fillStyle = "white"; ctx.font = "30px 'Press Start 2P'"; ctx.textAlign = "center";
        ctx.fillText("SELECT TRACK LENGTH", canvas.width/2, 100);
        ctx.font = "16px 'Press Start 2P'"; 
        
        const trackOptions = [
            { id: 'QUARTER_MILE', label: '1/4 MILE', color: "#0F0" },
            { id: 'HALF_MILE', label: '1/2 MILE', color: "#FF0" },
            { id: 'ONE_MILE', label: '1 MILE', color: "#F00" }
        ];

        for(let i = 0; i < trackOptions.length; i++) {
            const option = trackOptions[i];
            const xCenter = canvas.width * (i + 1) / 4;
            const isSelected = option.id === selectedTrack;
            
            ctx.fillStyle = isSelected ? option.color : "#555";
            ctx.fillRect(xCenter - 100, 200, 200, 100);
            
            ctx.fillStyle = isSelected ? "black" : "white";
            ctx.font = "20px 'Press Start 2P'";
            ctx.fillText(option.label, xCenter, 240);
            
            ctx.font = "10px 'Press Start 2P'";
            ctx.fillText(TRACK_DEFINITIONS[option.id].toFixed(0) + "m", xCenter, 270);
        }

        ctx.font = "12px 'Press Start 2P'"; ctx.fillStyle = "white";
        
        if (!isPvP) {
            ctx.fillText(`Difficulty: ${difficulty}`, canvas.width/2, 350);
            ctx.fillText(`Entry: ${formatCurrency(RACE_COSTS[difficulty])}`, canvas.width/2, 380);
            ctx.fillText(`Win: ${formatCurrency(RACE_PAYOUTS[difficulty])}`, canvas.width/2, 410);
        } else {
            ctx.fillText(`PvP Race - No Cost/Payout`, canvas.width/2, 380);
        }
        
        if (gameMessage) {
            ctx.fillStyle = "red";
            ctx.font = "15px 'Press Start 2P'";
            ctx.fillText(gameMessage, canvas.width/2, 450);
        } else {
            ctx.fillStyle = "white"; 
            ctx.font = "15px 'Press Start 2P'";
            ctx.fillText("Use Left/Right Arrows, Press ENTER to Race", canvas.width/2, 480);
            
            const backText = isPvP ? "Car Select" : "Difficulty Select";
            ctx.fillText(`Press Down Arrow to go Back to ${backText}.`, canvas.width/2, 510);
        }
    }
    else {
        drawSkyAndGround();
        
        if (gameState === STATE_COUNTDOWN || (gameState === STATE_RACING && lightsState === 5)) {
            drawLights();
        }
        
        if (!isPvP) {
            cpu.draw(cameraX);
        } else {
            player2.draw(cameraX);
        }
        player.draw(cameraX);
        
        drawHUD();

        if (gameState === STATE_GAMEOVER || gameState === STATE_FALSE_START) {
            ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = "60px 'Press Start 2P'"; ctx.textAlign = "center";
            
            let parts = winnerText.split('\n');
            let mainResult = parts[0];
            let moneyResult = parts.length > 1 ? parts[1] : "";
            
            let color = "white";
            if (mainResult.includes("WINNER") || mainResult.includes("WINS")) color = "#0F0";
            else if (mainResult.includes("LOSER") || mainResult.includes("FALSE START!")) color = "#F00";

            ctx.fillStyle = color;
            
            if (Math.floor(frameCount / 10) % 2 === 0) ctx.fillText(mainResult, canvas.width/2, canvas.height/2 - 30);
            
            if (moneyResult) {
                 ctx.fillStyle = moneyResult.includes('+') ? "#0F0" : "#F00";
                 ctx.font = "20px 'Press Start 2P'";
                 ctx.fillText(moneyResult, canvas.width/2, canvas.height/2 + 30);
            }
            
            if (raceFinishTime > 0 && !isPvP) { 
                 let duration = (raceFinishTime - raceStartTime) / 1000;
                 let timeText = duration.toFixed(3) + "s";
                 
                 ctx.fillStyle = "white";
                 ctx.font = "30px 'Press Start 2P'";
                 ctx.fillText(timeText, canvas.width/2, canvas.height/2 + 80);
            }
            
            if (isPvP && finishedPlayers.length === 2) { 
                 let time1 = ((raceFinishTime - raceStartTime) / 1000).toFixed(3) + "s";
                 let time2 = ((raceFinishTime2 - raceStartTime) / 1000).toFixed(3) + "s";
                 
                 ctx.fillStyle = raceFinishTime < raceFinishTime2 ? "#0F0" : "white";
                 ctx.font = "20px 'Press Start 2P'";
                 ctx.fillText(`P1 Time: ${time1}`, canvas.width/2, canvas.height/2 + 60);
                 
                 ctx.fillStyle = raceFinishTime2 < raceFinishTime ? "#0F0" : "white";
                 ctx.fillText(`P2 Time: ${time2}`, canvas.width/2, canvas.height/2 + 95);
            }
            
            if (showRestart) {
                ctx.fillStyle = "white"; ctx.font = "20px 'Press Start 2P'"; ctx.fillText("PRESS SPACE FOR MODE SELECT", canvas.width/2, canvas.height/2 + 150);
            }
        }
    }
}


// Start the game loop
loop();

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

</script>
</body>
</html>

